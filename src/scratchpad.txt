

std::chrono::year_month_day formatChronoDate(std::string dateStr)
{
	unsigned int day, month;
	int year;

	std::sscanf(dateStr.c_str(), "%d-%d-%d", &day, &month, &year);

	std::chrono::day chronoDay{day};
	std::chrono::month chronoMonth{month};
	std::chrono::year chronoYear{year};

	std::chrono::year_month_day chronoDate(chronoYear, chronoMonth, chronoDay);

	return chronoDate;
} 


// Chrono development
	std::string inputDate{"2-8-2025"};

	// formatChronoDate(inputDate);

	std::chrono::year_month_day projectStartDate{formatChronoDate(inputDate)};

	std::chrono::year_month_day projectEndDate{formatChronoDate("30-9-2025")};

	// std::chrono::sys_days sysProjectEndDate = std::chrono::sys_days(projectEndDate);
	// std::chrono::sys_days sysProjectStartDate = std::chrono::sys_days(projectStartDate);

	std::chrono::days duration{std::chrono::sys_days(projectEndDate) - std::chrono::sys_days(projectStartDate)};

	std::cout << "Number of days between the dates: " << duration.count() << " days\n";

	std::ostringstream oss;
	oss << std::setw(2) << std::setfill('0') << static_cast<unsigned>(projectStartDate.day()) << '-'
		<< std::setw(2) << std::setfill('0') << static_cast<unsigned>(projectStartDate.month()) << '-'
		<< static_cast<int>(projectStartDate.year());

	std::string dateStr = oss.str();
	std::cout << dateStr << '\n';


	// Chrono Notes
	


	// Openssl generate a hash
	std::string generateHash(const std::string &input)
{
	EVP_MD_CTX *ctx = EVP_MD_CTX_new(); // Create digest context
	if (!ctx)
		throw std::runtime_error("Failed to create EVP_MD_CTX");

	if (EVP_DigestInit_ex(ctx, EVP_sha256(), nullptr) != 1)
		throw std::runtime_error("EVP_DigestInit_ex failed");

	if (EVP_DigestUpdate(ctx, input.c_str(), input.size()) != 1)
		throw std::runtime_error("EVP_DigestUpdate failed");

	unsigned char hash[EVP_MAX_MD_SIZE];
	unsigned int length = 0;

	if (EVP_DigestFinal_ex(ctx, hash, &length) != 1)
		throw std::runtime_error("EVP_DigestFinal_ex failed");

	EVP_MD_CTX_free(ctx); // Clean up

	// Convert to hex string
	std::ostringstream oss;
	for (unsigned int i = 0; i < length; ++i)
		oss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];

	return oss.str();
}


// Openssl Commandline
// create private key
openssl genrsa -aes-256-cbc -out alice_private.key
openssl genrsa -aes-256-cbc -out bob_private.key

// create public key
openssl rsa -in alice_private.key -pubout > alice_public.key
openssl rsa -in bob_private.key -pubout > bob_public.key

// encrypt the file 'message' with bob_public.key
openssl pkeyautl -encrypt -inkey bob_public.key -pubin -in message -out message.encrypt

// sign the message.encrypt 
openssl dgst -sha256 -sign alice_private.key -out message.signature message.encrypt
openssl base64 -in message.signature -out alice_signature

// copy the message.encrypt and alice_signature files to bob
cp alice_signature ../bob/
cp message_encrypt ../bob/

// move to bob folder

// use the alice_signature file to get the message.signature
openssl base64 -d -in alice_signature -out message.signed

// verify that the message.encrypt file has come from alice_signature
openssl dgst -sha256 -verify alice_public.key -signature message.signature message.encrypt

Verified OK

// now Bob can decrpt the message.encrypt file
openssl pkeyutl -decrypt -inkey bob_private.key -in message.encrypt > message

// view the message
cat message
